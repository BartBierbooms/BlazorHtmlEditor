# HtmlEditor for Blazor

## Preface
I was working on an article where I needed complex logic. The article was based on a Blazor project. I decided to build an HTMLEditor prototype because it contains complex logic and implicit choices
If only I hadn't done it, because this was more difficult than I had imagined.
Fortunately, AngleSharp offered a solution. AngleSharp parses HTML to a Document class structure. Everything in .Net. The idea is to base the editor engine on Angleharp.

## Design and setup
The setup is as follows: the project HTMBuilder is a class library with core editor functionality. That is pure .Net, without UI, with an accompanying test project.
The HTMLEditableContent project is a Blazor component with a contentEditable div. It calls HtmlBuilder to render HTML in a contentEditable div.
BlazorHtmlEditor is a Blazor component built around HtmlEditableContent. The UI shell is programmed with MatBlazor (Material Design for Blazor).
This design was chosen because you can replace each component with your own component. If you don't want a Material Design editor, you can build your own UI shell. If you only want the logic then the HTMLBuilder is enough.

## Warning
All projects are experimental and can all be programmed much better. The intention is only to demonstrate how to build an HtmlEditor in Blazor. For example, I haven't taken the time to fully familiarize myself with AngleSharp, nor took the time to programm a fully featured HTML-editor. Also, I have not tested everything in all Browsers. That takes a lot more time. My main concern is the challenges encountered in building a Blazor HTML Editor.

## Challenges
The biggest challenge is the combination of Blazor binding combined with a contentEditable HTML element. At first I used binding. The HTML generated by AngleSharp was bound to the HTML element via a MarkUpString.
The problem is that the browser implements the changes in a contenteditable element in a MutationObserver-like manner. After Blazor, via binding, has updated the HTML, the Browser sees that the element has been changed and then also starts working.
The only way to work around that is not to use Blazor binding, but to update the HTML element via javascript via Interop.
Another problem was that the Editor Blazor component and the HtmlEditableContent Blazor component have to communicate with each other. For example, the Editor wants to show changes in the cursor position. If you implement this link via Parameter bindings, Blazor will consider any cursor position change as a Parameter change, including rendering. You don't want that at all.
This was solved by putting a shared class between the Editor and HtmlEditableContent component. The editor registers an editor interface in a static dictionary and the EditableContent registers an Htmlbuilder interface in another static dictionary. The dictionary will be shared between the two components. Both the Editor and the Content component have an ID property (Guid) and it is shared (via a parameter). Because they have the same key, they can request each other's interfaces in the shared libraries, without any renderings taking place. It is not ideal, but it works.

## A closer look at the HtmlEditableContent
If a user changes the cursor or selection in the browser, these position changes are passed via javascript to the Blazor component. Content changes are not immediately communicated.
If the .Net side has to perform an operation, it asks the Browser for the positions and the content (innerHTML). Then, AngleSharp parses the document and performs the operation. The result is new HTML content. Via javascript the old content is replaced by the new and the cursor selection positions are restored.
This setup limits the number of interactions between the javascript and the blazor side. The exception to this are position changes.

## What now?
Study the code, play with it yourself, make improvements and extensions, make suggestions, improve the UI and so on. You can, for eample, pass to the Editor styles/colors and fonts via parameters.
Despite all the difficulties, it remains a pleasure to work with Blazor.



